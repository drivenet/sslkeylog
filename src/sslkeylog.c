/*
 * Dumps master keys for OpenSSL clients to file. The format is documented at
 * https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format
 * Supports TLS 1.3 when used with OpenSSL 1.1.1.
 *
 * Copyright (C) 2014 Peter Wu <peter@lekensteyn.nl>
 * Licensed under the terms of GPLv3 (or any later version) at your choice.
 *
 * Usage:
 *  cc sslkeylog.c -shared -o libsslkeylog.so -fPIC -ldl
 *  SSLKEYLOGFILE=premaster.txt LD_PRELOAD=./libsslkeylog.so openssl ...
 *
 * Usage for macOS:
 *  cc sslkeylog.c -shared -o libsslkeylog.dylib -fPIC -ldl \
 *      -I/usr/local/opt/openssl@1.1/include \
 *      -L/usr/local/opt/openssl@1.1/lib -lssl
 *  DYLD_INSERT_LIBRARIES=./libsslkeylog.dylib DYLD_FORCE_FLAT_NAMESPACE=1 \
 *      SSLKEYLOGFILE=premaster.txt /usr/local/opt/openssl@1.1/bin/openssl ...
 */

#define _GNU_SOURCE /* for RTLD_NEXT */
#include <dlfcn.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/socket.h>

#define FIRSTLINE   "# SSL key logfile generated by sslkeylog.c\n"
#define FIRSTLINE_LEN (sizeof(FIRSTLINE) - 1)

static int keylog_file_fd = -1;

static void init_keylog_file(void)
{
    if (keylog_file_fd >= 0)
        return;

    const char *filename = getenv("SSLKEYLOGFILE");
    if (filename) {
        keylog_file_fd = open(filename, O_WRONLY | O_APPEND | O_CREAT, 0644);
        if (keylog_file_fd >= 0 && lseek(keylog_file_fd, 0, SEEK_END) == 0) {
            /* file is opened successfully and there is no data (pos == 0) */
            write(keylog_file_fd, FIRSTLINE, FIRSTLINE_LEN);
        }
    }
}

/* Key extraction via the new OpenSSL 1.1.1 API. */
static void keylog_callback(const SSL *ssl, const char *line)
{
    init_keylog_file();
    if (keylog_file_fd >= 0) {
        int peer_fd = SSL_get_fd(ssl);
        if (peer_fd >= 0) {
            struct sockaddr addr;
            socklen_t addr_len = sizeof(addr);
            if (getpeername(peer_fd, &addr, &addr_len) == 0) {
                const char* addr_name = NULL;
                unsigned short port = 0;
                char buffer[INET6_ADDRSTRLEN];
                switch (addr.sa_family)
                {
                    case AF_INET:
                        addr_name = inet_ntop(AF_INET, &((struct sockaddr_in*)&addr)->sin_addr, buffer, sizeof(buffer));
                        port = ntohs(((struct sockaddr_in*)&addr)->sin_port);
                        break;
            
                    case AF_INET6:
                        addr_name = inet_ntop(AF_INET6, &((struct sockaddr_in6*)&addr)->sin6_addr, buffer, sizeof(buffer));
                        port = ntohs(((struct sockaddr_in6*)&addr)->sin6_port);
                        break;
            
                    default:
                        break;
                }

                if (addr_name) {
                    write(keylog_file_fd, addr_name, strlen(addr_name));
                } else {
                    fprintf(stderr, "sslkeylog: Failed to get peer address for fd %d, errno: %d\n", peer_fd, errno);
                    write(keylog_file_fd, "?", 1);
                }

                if (port != 0) {
                    sprintf(buffer, "%hu", port);
                    write(keylog_file_fd, ":", 1);
                    write(keylog_file_fd, buffer, strlen(buffer));
                }
            } else {
                fprintf(stderr, "sslkeylog: Failed to get peer name for fd %d, errno: %d\n", peer_fd, errno);
                write(keylog_file_fd, "?", 1);
            }
    
            write(keylog_file_fd, " ", 1);

            addr_len = sizeof(addr);
            if (getsockname(peer_fd, &addr, &addr_len) == 0) {
                const char* addr_name = NULL;
                unsigned short port = 0;
                char buffer[INET6_ADDRSTRLEN];
                switch (addr.sa_family)
                {
                    case AF_INET:
                        addr_name = inet_ntop(AF_INET, &((struct sockaddr_in*)&addr)->sin_addr, buffer, sizeof(buffer));
                        port = ntohs(((struct sockaddr_in*)&addr)->sin_port);
                        break;
            
                    case AF_INET6:
                        addr_name = inet_ntop(AF_INET6, &((struct sockaddr_in6*)&addr)->sin6_addr, buffer, sizeof(buffer));
                        port = ntohs(((struct sockaddr_in6*)&addr)->sin6_port);
                        break;
            
                    default:
                        break;
                }

                if (addr_name) {
                    write(keylog_file_fd, addr_name, strlen(addr_name));
                }
                else {
                    fprintf(stderr, "sslkeylog: Failed to get socket address for fd %d, errno: %d\n", peer_fd, errno);
                    write(keylog_file_fd, "?", 1);
                }

                if (port != 0) {
                    sprintf(buffer, "%hu", port);
                    write(keylog_file_fd, ":", 1);
                    write(keylog_file_fd, buffer, strlen(buffer));
                }
            }
            else {
                fprintf(stderr, "sslkeylog: Failed to get socket name for fd %d, errno: %d\n", peer_fd, errno);
                write(keylog_file_fd, "?", 1);
            }
        } else {
            fprintf(stderr, "sslkeylog: Failed to get fd for SSL, errno: %d\n", errno);
            write(keylog_file_fd, "? ?", 1);
        }
    
        write(keylog_file_fd, " ", 1);

        const char* client_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
        if (client_name) {
            write(keylog_file_fd, client_name, strlen(client_name));
        }

        write(keylog_file_fd, " ", 1);
        write(keylog_file_fd, line, strlen(line));
        write(keylog_file_fd, "\n", 1);
    }
}

SSL *SSL_new(SSL_CTX *ctx)
{
    static SSL *(*func)();
    if (!func) {        
        func = dlsym(RTLD_NEXT, __func__);
        if (!func) {
            fprintf(stderr, "sslkeylog: Cannot lookup %s\n", __func__);
            abort();
        }
    }
    /* Override any previous key log callback. */
    SSL_CTX_set_keylog_callback(ctx, keylog_callback);
    return func(ctx);
}
